========================================================================
Empty test
========================================================================
//
------------------------------------------------------------------------
ok

========================================================================
Generic function with no arguments: explicit type argument
========================================================================
fun generic<T>(): T {}

fun main() {
    val foo = generic<int>();
//!     ^ int
}
------------------------------------------------------------------------
ok

========================================================================
Generic function with no arguments: explicit two type arguments and union type
========================================================================
fun generic<T, U>(): T | U {}

fun main() {
    val foo = generic<int, slice>();
//!     ^ int | slice
}
------------------------------------------------------------------------
ok

========================================================================
Generic function with no arguments: explicit two type arguments and tuple type
========================================================================
fun generic<T, U>(): [T, U] {}

fun main() {
    val foo = generic<int, slice>();
//!     ^ [int, slice]
}
------------------------------------------------------------------------
ok

========================================================================
Generic function with no arguments: explicit two type arguments and tuple type 2
========================================================================
fun generic<T, U>(): [T | U, U] {}

fun main() {
    val foo = generic<int, slice>();
//!     ^ [int | slice, slice]
}
------------------------------------------------------------------------
ok

========================================================================
Generic function with no arguments: explicit two type arguments and tensor type
========================================================================
fun generic<T, U>(): (T, U) {}

fun main() {
    val foo = generic<int, slice>();
//!     ^ (int, slice)
}
------------------------------------------------------------------------
ok

========================================================================
Generic function with no arguments: explicit two type arguments and function type
========================================================================
fun generic<T, U>(): (T) -> U {}

fun main() {
    val foo = generic<int, slice>();
//!     ^ (int) -> slice

    val res = foo();
//!     ^ slice
}
------------------------------------------------------------------------
ok

========================================================================
Generic function with single arguments: explicit struct type
========================================================================
struct Foo {
    value: int,
}

fun generic<T>(a: T): T {}

fun main() {
    val foo =
//!     ^ Foo
        generic<Foo>({
//!                  ^ Foo
            value: 10,
//!         ^ int
        });
}
------------------------------------------------------------------------
ok

========================================================================
Generic method toCell
========================================================================
struct Cell<T> {}

fun T.toCell2(self): Cell<T> {}

fun main() {
    val foo = 10.toCell2();
//!     ^ Cell<int>
}
------------------------------------------------------------------------
ok

========================================================================
Generic method as right hand of ternary inside other generic function call
========================================================================
fun eq<T1>(a: T1): [T1] {
    return [a];
}

fun eq2<X>(value: X) { return value; }

fun name(f: int) {
    eq(f ? null as int? : eq2(2));
//!                     ^ int?
}
------------------------------------------------------------------------
ok
